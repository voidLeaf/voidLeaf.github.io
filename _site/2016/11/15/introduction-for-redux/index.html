<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      理解Redux &middot; 片虚
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/lanyon.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body>

    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p>Like a void leaf</p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item" href="/">Home</a>

    

    
    
      
        
      
    
      
        
      
    
      
        
          <a class="sidebar-nav-item" href="/about/">About</a>
        
      
    
      
    

    <a class="sidebar-nav-item" href="/archive/v1.0.0.zip">Download</a>
    <a class="sidebar-nav-item" href="">GitHub project</a>
    <span class="sidebar-nav-item">Currently v1.0.0</span>
  </nav>

  <div class="sidebar-item">
    <p>
      &copy; 2016. All rights reserved.
    </p>
  </div>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="/" title="Home">片虚</a>
            <small>Like a void leaf</small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="post">
  <h1 class="post-title">理解Redux</h1>
  <span class="post-date">15 Nov 2016</span>
  <h2 id="react-">从 React 说起</h2>

<p>刚开始接触 react 的时候其实是感到非常惊艳的，在 React 的架构下可以像搭积木一样把前端的视图组件组合在一起，非常好玩<!--more-->，React 这种模块化的结构保证了组件内部的高度自治性，使得前端开发高度正交化。以至于刚刚使用 React 的时候简直觉得是在上帝之手的帮助之下写前端，触手丝滑，效率飞起，但是用了一段时间之后就很快发现了一些问题，比如父组件可以通过给子组件赋值 props，但是子组件向父组件传值却只能通过较为复杂的双向绑定，如果要向不是父子关系的组件传值怎么办呢？React 的文档会告诉你只能再 copy 一个组件过来了。EXM？组件之间传值这么常见的操作 React 却只能给出一个这么简单粗暴的办法？负分！差评！</p>

<p>但是知道了 Redux 这么一个神奇的存在之后，感觉 React 终于有救了，在 Redux 的框架之下，所有的状态被集中起来统一管理，使得应用内的数据完美地同步起来，爸爸再也不用担心收不到儿子的消息啦</p>

<p>当然这里要提一下，Redux 本身是一个单独的框架，跟 React 没什么关系，但是由于在 React 的框架下视图和 state 和 view 是一一对应的，这样就使得 Redux 更适用于 React 环境下的开发</p>

<h2 id="redux-">Redux 的基本思想</h2>

<p>Redux 是一个基于Flux思想实现的一个针对web应用的状态管理库，在Redux 里 Web 应用被视为一个有穷状态机，在这个状态机里所有状态的变化都是可以追溯甚至是可以撤销的，为了实现这样的机制，Redux 进行了以下三个约束：</p>

<ul>
  <li>所有的 state 构成一棵 object tree，这棵 object tree 只存在于唯一一个store 中。</li>
  <li>所有state都是只读的，唯一改变 state 的方法是触发 action</li>
  <li>使用纯函数来执行修改，以保证每次对状态修改的执行结果都是一致的</li>
</ul>

<p>在 redux 中主要引入了 action、reducer、store 这三个概念，action 用于定义一个请求，reducer 用于根据 action 产生新状态，store 用于存储和管理 state，监听 action，将 action 自动分配给 reducer 并根据 reducer 的执行结果更新 state。</p>

<p>在这里你可以根据字面意思把 store 想象成一个仓库，这个仓库里的货物就是 state ，但是这个仓库的管理员实在是懒得跟自己的客户沟通，就请了好几个助手来帮自己，比如助手 A 专门负责某个手机厂商的请求，助手B专门负责电脑厂商的请求，他们计算好进出货量之后通知管理员，管理员如果接到手机厂商的请求就把他分配给 A，接到电脑厂商的请求就分配给B，得到 A 和 B 的结果之后管理员就可以马上更新仓库了，在这里这些助手就是 reducer，像手机和电脑厂商的请求就是 action。执行任务分配的这个过程就是 <code class="highlighter-rouge">store.despatch(action)</code> 函数 。</p>

<h2 id="redux--1">Redux 的基本概念</h2>

<h3 id="action">Action</h3>

<p>action 是把数据从应用传到 store 的有效载荷。它是 store 数据的<strong>唯一</strong>来源。用来表明一个事件的发生，但并不对状态如何修改做任何描述。一个action 的结构是一个 javascript 普通对象，一个 action 的结构如下</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="p">{</span>
  <span class="c1">//type字段用于标识action的类型，一般用一个字符串来表示</span>
  <span class="nl">type</span><span class="p">:</span> <span class="s1">'ADD_TODO'</span><span class="p">,</span>
  <span class="c1">//text是用户自定义的字段，一般用来传递和状态修改相关的参数</span>
  <span class="nx">text</span><span class="err">:</span> <span class="s1">'Build my first Redux app'</span>
<span class="p">}</span>
</code></pre>
</div>

<h3 id="reducer">Reducer</h3>

<p>action 只是描述了<strong>有事情发生了</strong>这一事实，但是并没有指名如何更新 state，reducer 就是对状态修改过程的描述，但是需要注意的有以下两点：</p>

<ul>
  <li>
    <p>由于状态是<strong>只读</strong>的，reducer 本身并不能真正实现状态的修改，而是只把新状态作为返回值返回。</p>
  </li>
  <li>
    <p>为了确保每次对状态修改的结果都是一致的，reducer 必须是一个<strong>纯函数</strong>，也就是说，只要是同样的输入，必定得到同样的输出。纯函数需要遵循以下约束：</p>

    <div class="highlighter-rouge"><pre class="highlight"><code><span class="err">不得改写参数</span>
<span class="err">不能调用系统</span> <span class="nx">I</span><span class="o">/</span><span class="nx">O</span> <span class="err">的</span><span class="nx">API</span>
<span class="err">不能调用</span><span class="nb">Date</span><span class="p">.</span><span class="nx">now</span><span class="p">()</span><span class="err">或者</span><span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">()</span><span class="err">等不纯的方法，因为每次会得到不一样的结果</span>
</code></pre>
    </div>

    <p>一个 reducer 的结构如下</p>
  </li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="cm">/* 在这个 reducer 中，对于一个类型为 ADD_TODO 的 action，返回的新状态是在传入状态数组中追加了一个元素 */</span>
<span class="kd">function</span> <span class="nx">todos</span><span class="p">(</span><span class="nx">state</span> <span class="o">=</span> <span class="p">[],</span> <span class="nx">action</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="nx">action</span><span class="p">.</span><span class="nx">type</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nx">ADD_TODO</span><span class="err">:</span>
      <span class="k">return</span> <span class="p">[</span>
        <span class="p">...</span><span class="nx">state</span><span class="p">,</span>
        <span class="p">{</span>
          <span class="na">text</span><span class="p">:</span> <span class="nx">action</span><span class="p">.</span><span class="nx">text</span><span class="p">,</span>
          <span class="na">completed</span><span class="p">:</span> <span class="kc">false</span>
        <span class="p">}</span>
      <span class="p">]</span>
      <span class="nl">default</span><span class="p">:</span>
      	  <span class="k">return</span> <span class="nx">state</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<h3 id="store">Store</h3>

<p>在定义了描述事件发生的 action 和描述状态修改方案的 reducer 之后，如何把它们联系到一起真正实现状态的改变呢？这就要牵扯到 store 啦，前面已经提过 redux 的原则之一就是所有的 state 构成的对象树都存到了 store 中，除此之外 store 还有以下功能：</p>

<ul>
  <li>维持应用的 state</li>
  <li>提供 <code class="highlighter-rouge">getState()</code> 方法获取 state</li>
  <li>提供 <code class="highlighter-rouge">dispatch(action)</code>方法更新 state；</li>
  <li>通过 <code class="highlighter-rouge">subscribe(listener)</code>注册监听器;</li>
  <li>通过 <code class="highlighter-rouge">subscribe(listener)</code>返回的函数注销监听器。</li>
</ul>

<p>创建一个 store 其实很简单：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="kr">import</span> <span class="p">{</span> <span class="nx">createStore</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">'redux'</span>
<span class="kr">import</span> <span class="nx">reducers</span> <span class="nx">from</span> <span class="s1">'./reducers'</span>
<span class="kd">let</span> <span class="nx">store</span> <span class="o">=</span> <span class="nx">createStore</span><span class="p">(</span><span class="nx">reducers</span><span class="p">)</span>
</code></pre>
</div>

<p><a href="http://www.redux.org.cn/docs/api/createStore.html"><code class="highlighter-rouge">createStore()</code></a> 的第二个参数是可选的, 用于设置 state 初始状态。这对开发同构应用时非常有用，服务器端 redux 应用的 state 结构可以与客户端保持一致, 那么客户端可以将从网络接收到的服务端 state 直接用于本地数据初始化。</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">store</span> <span class="o">=</span> <span class="nx">createStore</span><span class="p">(</span><span class="nx">todoApp</span><span class="p">,</span> <span class="nb">window</span><span class="p">.</span><span class="nx">STATE_FROM_SERVER</span><span class="p">)</span>
</code></pre>
</div>

<p>接下来就可以简单实现一个创建处理 action 的过程了</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="kr">import</span> <span class="p">{</span> <span class="nx">createStore</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">'redux'</span>
<span class="kr">const</span> <span class="nx">ADD_TODO</span> <span class="o">=</span> <span class="s1">'ADD_TODO'</span>
<span class="c1">//创建一个 action</span>
<span class="kr">const</span> <span class="nx">simpleAction1</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">type</span><span class="p">:</span> <span class="s1">'ADD_TODO'</span><span class="p">,</span>
  <span class="na">text</span><span class="p">:</span> <span class="s1">'Build my first Redux app'</span>
<span class="p">}</span>
<span class="kr">const</span> <span class="nx">simpleAction2</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">type</span><span class="p">:</span> <span class="s1">'ADD_TODO'</span><span class="p">,</span>
  <span class="na">text</span><span class="p">:</span> <span class="s1">'Build my second Redux app'</span>
<span class="p">}</span>
<span class="c1">//创建一个 reducer, 功能为收到类型为 ADD_TODO 的 action 后为在 state 中添加一个条目</span>
<span class="kd">function</span> <span class="nx">reducer</span><span class="p">(</span><span class="nx">state</span> <span class="o">=</span> <span class="p">[],</span> <span class="nx">action</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="nx">action</span><span class="p">.</span><span class="nx">type</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nx">ADD_TODO</span><span class="err">:</span>
      <span class="k">return</span> <span class="p">[</span>
        <span class="p">...</span><span class="nx">state</span><span class="p">,</span>
        <span class="p">{</span>
          <span class="na">text</span><span class="p">:</span> <span class="nx">action</span><span class="p">.</span><span class="nx">text</span><span class="p">,</span>
          <span class="na">completed</span><span class="p">:</span> <span class="kc">false</span>
        <span class="p">}</span>
      <span class="p">]</span>
      <span class="nl">default</span><span class="p">:</span>
      	  <span class="k">return</span> <span class="nx">state</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="c1">//创建一个初始状态为空数组的 store</span>
<span class="kd">let</span> <span class="nx">store</span> <span class="o">=</span> <span class="nx">createStore</span><span class="p">(</span><span class="nx">reducer</span><span class="p">,[])</span>

<span class="c1">// 打印初始状态</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">store</span><span class="p">.</span><span class="nx">getState</span><span class="p">())</span>

<span class="c1">// 每次 state 更新时，打印日志</span>
<span class="c1">// 注意 subscribe() 返回一个函数用来注销监听器</span>
<span class="kd">let</span> <span class="nx">unsubscribe</span> <span class="o">=</span> <span class="nx">store</span><span class="p">.</span><span class="nx">subscribe</span><span class="p">(()</span> <span class="o">=&gt;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">store</span><span class="p">.</span><span class="nx">getState</span><span class="p">())</span>
<span class="p">)</span>
<span class="c1">// 发起一个 action, 执行之后会更新状态，由于注册了监听器你可以看到每次更新都会打印当前状态</span>
<span class="nx">store</span><span class="p">.</span><span class="nx">dispatch</span><span class="p">(</span><span class="nx">simpleAction1</span><span class="p">)</span>
<span class="nx">store</span><span class="p">.</span><span class="nx">dispatch</span><span class="p">(</span><span class="nx">simpleAction1</span><span class="p">)</span>

<span class="c1">// 停止监听 state 更新</span>
<span class="nx">unsubscribe</span><span class="p">();</span>
</code></pre>
</div>

</div>

<div class="related">
  <h2>Related Posts</h2>
  <ul class="related-posts">
    
      <li>
        <h3>
          <a href="/2015/09/23/sparktest/">
            spark基本命令
            <small>23 Sep 2015</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/2015/09/23/nodejsnote/">
            node.js 笔记（全局变量）
            <small>23 Sep 2015</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/%E6%9C%AA%E5%88%86%E7%B1%BB/2015/09/04/fold/">
            折叠
            <small>04 Sep 2015</small>
          </a>
        </h3>
      </li>
    
  </ul>
</div>

      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script>
      (function(document) {
        var toggle = document.querySelector('.sidebar-toggle');
        var sidebar = document.querySelector('#sidebar');
        var checkbox = document.querySelector('#sidebar-checkbox');

        document.addEventListener('click', function(e) {
          var target = e.target;

          if(!checkbox.checked ||
             sidebar.contains(target) ||
             (target === checkbox || target === toggle)) return;

          checkbox.checked = false;
        }, false);
      })(document);
    </script>
  </body>
</html>
